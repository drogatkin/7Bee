// $Id: zip.java,v 1.5 2012/03/02 04:07:28 dmitriy Exp $
//Bee Copyright (c) 2011 Dmitriy Rogatkin
// Created on Jun 26, 2011
package org.bee.func;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.AbstractCollection;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Enumeration;
import java.util.function.Consumer;
import java.util.regex.Pattern;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import java.util.zip.ZipInputStream;
import java.util.zip.ZipOutputStream;

import org.bee.util.Misc;

/** provides a similar functionality to zip
 *  
 * @author Dmitriy
 *
 */
public class zip {
	public static final String ARCH_FOLDER = "!.";
	
	public static final String DIR_CONT = "/.";
	
	private static class Wildcard {
		Pattern pattern;
		boolean recursive;
	}

	/** main method of zipping
	 * 
	 * @param delPats 1 - zip archive name 2.. files to be zipped
	 * If an added file is already an archive and its name ended with '!.', 
	 * then its content added to the result zip.
    
	 * @return true if no error happened otherwise false
	 * 
	 */
	public static boolean eval(Object... args) {
		if (args.length < 2)
			return false;
		File zipFile = new File(args[0].toString());
		ZipOutputStream zs = null;
		File mergeWith = null;
		ZipInputStream zin =  null;
		ArrayList<String> added = new ArrayList<String>(); // set to null if duplicates considered as an error
		try {
			//System.out.printf("Zipping to %s args : %d%n", zipFile, args.length);
			//if (zipFile.createNewFile() == false) {
				//throw new IOException("Can't create zip file "+zipFile);
			//}
			ArrayList<String> parameters = new ArrayList<String>(args.length);
			if (zipFile.exists()) {
				mergeWith = File.createTempFile(zipFile.getName(), null);
				mergeWith.delete(); // check if success
				if(zipFile.renameTo(mergeWith) == false)
			        throw new RuntimeException("Could not rename the file "+zipFile.getAbsolutePath()+" to "+mergeWith.getAbsolutePath());
				parameters.add(mergeWith.getPath()+ARCH_FOLDER);
				//zin = new ZipInputStream(new FileInputStream(mergeWith));
				//added = new ArrayList<String>();
			}
			zs = new ZipOutputStream(new FileOutputStream(zipFile));
			zs.setLevel(ZipOutputStream.DEFLATED);
			zs.setComment("Generated by 7Bee, Copyright 2004 - 2022 by Dmitriy Rogatkin");
			
			for (int i = 1; i < args.length; i++) {
				if (args[i] instanceof Collection) {
					parameters.addAll((AbstractCollection<? extends String>) args[i]);
				} else if (args[i] instanceof Object[])
					for (Object o : (Object[]) args[i])
						parameters.add(o.toString());
				else
					parameters.add(args[i].toString());
			}
			final ArrayList<String> parameters2 = new ArrayList<String>(args.length);
			/*
			parameters.forEach((n) -> { if (n.endsWith("/.")) {
				File td = new File(n.substring(0, n.length()-2)); if (td.isDirectory()) {
					//String [] een =  td.list();
					for(String ne:td.list())
					parameters2.add(ne);
				}
			} else {
				parameters2.add(n);
			} });
			*/
			parameters.forEach(new Consumer<String>() {
	            @Override
	            public void accept(String n) {
	            	if (n.endsWith(DIR_CONT)) {
	    				File td = new File(n.substring(0, n.length()-DIR_CONT.length())); if (td.isDirectory()) {
	    					for(File ne:td.listFiles())
	    			     		parameters2.add(ne.getPath());
	    				}
	            	} else if (n.endsWith(ARCH_FOLDER)) {
	            		// there two strategies, continue files extraction in some temp directory, and then added its
	            		// content file by file (can be very space consuming and a temp location should be selected carefully),
	            		// or each file of the archive gets added in a form archive/!file_path_in_the_archive.
	            		parameters2.add(n); // an actual processing will happen later
	    			} else {
	    				parameters2.add(n);
	    			}
	            }
            });
			parameters = parameters2;
			zipFiles(null, parameters.toArray(new String[parameters.size()]), "", zs, added, null);
			/*if (zin != null) {
				ZipEntry entry = zin.getNextEntry();
			
				while (entry != null) {
					String name = entry.getName();
					if (!added.contains(name)) {
						zs.putNextEntry(new ZipEntry(name));
						Misc.copyStream(zin, zs, -1);
						zs.closeEntry();
					}
					entry = zin.getNextEntry();
				}
			}
			*/
			return true;
		} catch (IOException e) {
			System.err.printf("zip:error:io: %s%n", e);
			e.printStackTrace();
		} catch (Exception e) {
			System.err.printf("zip:error: %s%n", e);
			e.printStackTrace();
		} finally {
			if (zs != null)
				try {
					zs.close();
				} catch (Exception e) {
					
				}
			if (zin != null)
				try {
					zin.close();
				} catch (Exception e) {
					
				}
			if (mergeWith != null)
				mergeWith.delete();
		}
		return false;
	}

	private static void zipFiles(File folder, String[] selection, String current, ZipOutputStream zs, ArrayList<String> added, Wildcard wc)
			throws IOException {
		//System.out.printf("Processing: %s, %s / %s pat: %s%n", folder, Arrays.toString(selection), current, wc);
		for (String s : selection) {
			// if s has */? or ./ cut to dir, check it and create a pattern
			if (s.endsWith(ARCH_FOLDER)) {
				try (ZipFile zf = new ZipFile(s.substring(0, s.length()-ARCH_FOLDER.length()))) {
					for (final Enumeration<? extends ZipEntry> entries = zf.entries(); entries.hasMoreElements();) {
						 final ZipEntry entry = entries.nextElement();
						 if (added != null && added.contains(entry.getName()))
							 continue;
						 final ZipEntry newEntry = new ZipEntry(entry.getName());
						 newEntry.setLastModifiedTime(entry.getLastModifiedTime());
					     zs.putNextEntry(newEntry);
					     Misc.copyStream(zf.getInputStream( entry ) , zs, -1);
					        zs.closeEntry();
					        if (added != null)
							added.add(newEntry.getName());
					        // ?? need to close input stream
					}
				} catch(Exception e) {
					System.err.printf("zip:error:io: %s%n", e);
					e.printStackTrace();
				} 
				continue;
			}
			File f = folder==null?new File(s): new File(folder, s);
			if ((wc != null && wc.pattern.matcher(f.getName()).matches() || wc == null) && f.isFile() && f.canRead()) {
				ZipEntry e = new ZipEntry(current + f.getName());
				if (added != null)
					added.add(e.getName());
				e.setTime(f.lastModified());
				zs.putNextEntry(e);
				FileInputStream is;
				Misc.copyStream(is = new FileInputStream(f), zs, -1);
				zs.closeEntry();
				is.close(); // TODO move in finally
			} else if (f.isDirectory() && (wc != null && wc.recursive || wc == null)) {
				zipFiles(f, f.list(), current + f.getName() + '/', zs, added, null);
			} else if (folder == null) {
				// try wildcard but only when folder == null
				String[] mas = s.replace('\\','/').split("/");
				if (mas[mas.length-1].indexOf('*') > -1 || mas[mas.length-1].indexOf('?') > -1 ) {
					Wildcard wc1 = new Wildcard();
					wc1.pattern = Pattern.compile(Misc.wildCardToRegExpr(mas[mas.length-1]));
					wc1.recursive = mas.length > 2 && ".".equals(mas[mas.length-2]);
					String pat = Misc.join("/", mas, wc1.recursive?mas.length-2:mas.length-1);
					f = new File(pat);
					zipFiles(f, f.list(), "", zs, added, wc1);
				}
			}
		}
	}
}
